# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_camera_calibration.ipynb.

# %% auto #0
__all__ = ['capture_calibration_images', 'object_points_cheesboard_grid', 'saveCoefficients', 'loadCoefficients',
           'calibrate_camera_from_chessboard_images']

# %% ../nbs/01_camera_calibration.ipynb #c0ef6f64
import cv2
import numpy as np
import matplotlib.pyplot as plt
import glob
import os
from pathlib import Path

# %% ../nbs/01_camera_calibration.ipynb #f93c4663
def capture_calibration_images(num_images=20, res_width=2560, res_height=1440):
    """ 
    Capture images from the webcam for camera calibration.
    Press SPACE to capture an image, ESC to quit.
    Images are saved in the 'calibration_images' directory.
    Inputs:
        num_images: Pictures to be taken
        res_width: Resolution of the with of the picture taken by the camera in pixels
        res_height: Resolution of the height of the picture taken by the camera in pixels
    """
    cap = cv2.VideoCapture(0)

    # Set the resolution of the camera. OpenCV default is 640x480
    cap.set(cv2.CAP_PROP_FRAME_WIDTH, res_width)
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, res_height)

    if not cap.isOpened():
        print("Cannot open camera")
        return
    
    os.makedirs('calibration_images', exist_ok=True)
    count = 0
    
    while count < num_images:
        ret, frame = cap.read()
        if not ret:
            break
        
        # Copy the frame so we save it without annotations
        display_frame = frame.copy()
        cv2.putText(display_frame, f'Captured: {count}/{num_images}', (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)
        cv2.putText(display_frame, 'Press SPACE to capture, ESC to quit', (10, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
        cv2.imshow('Calibration Capture', display_frame)
        
        key = cv2.waitKey(1)
        if key == 32:  # Space
            cv2.imwrite(f'calibration_images/image_{count:02d}.png', frame)
            count += 1
            print(f'Captured image {count}')
        elif key == 27:  # ESC
            break
    
    cap.release()
    cv2.destroyAllWindows()

# %% ../nbs/01_camera_calibration.ipynb #960cc7b3
def object_points_cheesboard_grid(pattern_size: tuple[int, int]) -> np.ndarray:
    """
    Prepare object points based on the known flat chessboard pattern size, only the inner corners.
    Order of points is in C order (row-major).
    [ [0 0] -> [0 1] -> ... -> [0 n] -> [1 0] -> [1 1] -> ... -> [m n] ]
    Args:
        pattern_size (tuple[int, int]): Number of inner corners per chessboard row and column (nx, ny).
    Returns:
        np.ndarray: Array of 3D points in the world coordinate system.
    """
    # ---- Prepare object points based on the known flat chessboard pattern ----
    # Obtain a grid of 2D points
    points_2D = np.mgrid[0:pattern_size[0], 0:pattern_size[1]]
    # Reshape to a list of points with columns as (x, y)
    points_2D = points_2D.transpose(2, 1, 0).reshape(-1, 2)
    # 3D points assuming z=0 for all points (planar chessboard) [x, y, z]
    points_3D = np.hstack((points_2D, np.zeros((points_2D.shape[0], 1))))
    # We can cast here to float32 since this is used for camera calibration
    points_3D = points_3D.astype(np.float32)

    return points_3D

# %% ../nbs/01_camera_calibration.ipynb #1ce2c397
def saveCoefficients(mtx, dist, reprojection_error, save_path):
    """
    Save camera calibration coefficients to a yaml file.
     - mtx: Camera matrix
     - dist: Distortion coefficients
     - reprojection_error: Reprojection error of the calibration
     - save_path: Directory path where the yaml file will be saved. The file will be named 'camera_calibration.yaml'.
    """

    if not os.path.exists(save_path):
        os.makedirs(save_path)

    file_path = os.path.join(save_path, 'camera_calibration.yaml')
    cv_file = cv2.FileStorage(file_path, cv2.FILE_STORAGE_WRITE)
    cv_file.write("camera_matrix", mtx)
    cv_file.write("dist_coeff", dist)
    cv_file.write("reprojection_error", reprojection_error)
    cv_file.release()
    
def loadCoefficients(load_path):
    """ 
    Load camera calibration coefficients from a yaml file.
     - load_path: Path to the yaml file containing the calibration results.

    Returns: A list containing the camera matrix, distortion coefficients, and reprojection error.
    """

    # Check if the file exists
    if not os.path.exists(load_path):
        raise FileNotFoundError(f"Calibration file not found at {load_path}")

    cv_file = cv2.FileStorage(load_path, cv2.FILE_STORAGE_READ)

    # note we also have to specify the type to retrieve other wise we only get a
    # FileNode object back instead of a matrix
    camera_matrix = cv_file.getNode("camera_matrix").mat()
    dist_matrix = cv_file.getNode("dist_coeff").mat()
    reprojection_error = cv_file.getNode("reprojection_error").real()
    cv_file.release()
    return [camera_matrix, dist_matrix, reprojection_error]

# %% ../nbs/01_camera_calibration.ipynb #b2f00c64
def calibrate_camera_from_chessboard_images(image_files: list[str], pattern_size: tuple[int, int], f_save: bool=True):
    """
    Calibrate camera using multiple images of a chessboard pattern.
    
    Parameters:
    - image_files: List of file paths to calibration images.
    - pattern_size: Tuple indicating the number of inner corners per chessboard row and column (nx, ny).
    
    Returns:
    - camera_matrix: The camera matrix.
    - dist_coeffs: The distortion coefficients.
    - reprojection_error: The reprojection error of the calibration.
    """

    # Prepare object points based on the known flat chessboard pattern (cast to float32)
    objp = object_points_cheesboard_grid(pattern_size).astype(np.float32)

    # List of 3D points for each image
    objpoints = []  # 3d point in real world space
    imgpoints = []  # 2d points in image plane.
    # ---------------------------------------------------------------------
    # Criteria for cornerSubPix
    winSize = (11,11)
    zeroZone = (-1,-1) # no dead region
    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001) # max 30 iterations or move by at least 0.001


    for fname in image_files:
        img = cv2.imread(fname)
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

        ret, corners = cv2.findChessboardCorners(gray, pattern_size, None)

        if ret:
            corners_subpix = cv2.cornerSubPix(gray, corners, winSize, zeroZone, criteria)
            objpoints.append(objp)
            imgpoints.append(corners_subpix)

    _, camera_matrix, dist_coeffs, rvecs, tvecs = cv2.calibrateCamera(objpoints, imgpoints, gray.shape[::-1], None, None)

    # Calculate reprojection error
    mean_error = 0
    for i in range(len(objpoints)):
        imgpoints2, _ = cv2.projectPoints(objpoints[i], rvecs[i], tvecs[i], camera_matrix, dist_coeffs)
        error = cv2.norm(imgpoints[i], imgpoints2, cv2.NORM_L2) / len(imgpoints2)
        mean_error += error
    reprojection_error = mean_error / len(objpoints)
    
    print(f"\nTotal reprojection error: {reprojection_error}")
    
    # Save the calibration results
    if f_save:
        save_path = os.path.dirname(image_files[0])
        # Save as a yaml file
        saveCoefficients(camera_matrix, dist_coeffs, reprojection_error, os.path.join(save_path, 'camera_calibration.yaml'))
        print(f"Calibration results saved to {os.path.join(save_path, 'camera_calibration.yaml')}")

    
    return camera_matrix, dist_coeffs, reprojection_error
