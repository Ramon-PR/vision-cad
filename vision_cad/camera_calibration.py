# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_camera_calibration.ipynb.

# %% auto #0
__all__ = ['capture_calibration_images', 'object_points_cheesboard_grid', 'calibrate_camera_from_chessboard_images']

# %% ../nbs/01_camera_calibration.ipynb #c0ef6f64
import cv2
import numpy as np
import matplotlib.pyplot as plt
import glob
import os

# %% ../nbs/01_camera_calibration.ipynb #f93c4663
def capture_calibration_images(num_images=20):
    """ 
    Capture images from the webcam for camera calibration.
    Press SPACE to capture an image, ESC to quit.
    Images are saved in the 'calibration_images' directory.
    """
    cap = cv2.VideoCapture(0)
    if not cap.isOpened():
        print("Cannot open camera")
        return
    
    os.makedirs('calibration_images', exist_ok=True)
    count = 0
    
    while count < num_images:
        ret, frame = cap.read()
        if not ret:
            break
        
        # Copy the frame so we save it without annotations
        display_frame = frame.copy()
        cv2.putText(display_frame, f'Captured: {count}/{num_images}', (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)
        cv2.putText(display_frame, 'Press SPACE to capture, ESC to quit', (10, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
        cv2.imshow('Calibration Capture', display_frame)
        
        key = cv2.waitKey(1)
        if key == 32:  # Space
            cv2.imwrite(f'calibration_images/image_{count:02d}.png', frame)
            count += 1
            print(f'Captured image {count}')
        elif key == 27:  # ESC
            break
    
    cap.release()
    cv2.destroyAllWindows()

# %% ../nbs/01_camera_calibration.ipynb #960cc7b3
def object_points_cheesboard_grid(pattern_size: tuple[int, int]) -> np.ndarray:
    """
    Prepare object points based on the known flat chessboard pattern size, only the inner corners.
    Order of points is in C order (row-major).
    [ [0 0] -> [0 1] -> ... -> [0 n] -> [1 0] -> [1 1] -> ... -> [m n] ]
    Args:
        pattern_size (tuple[int, int]): Number of inner corners per chessboard row and column (nx, ny).
    Returns:
        np.ndarray: Array of 3D points in the world coordinate system.
    """
    # ---- Prepare object points based on the known flat chessboard pattern ----
    # Obtain a grid of 2D points
    points_2D = np.mgrid[0:pattern_size[0], 0:pattern_size[1]]
    # Reshape to a list of points with columns as (x, y)
    points_2D = points_2D.transpose(2, 1, 0).reshape(-1, 2)
    # 3D points assuming z=0 for all points (planar chessboard) [x, y, z]
    points_3D = np.hstack((points_2D, np.zeros((points_2D.shape[0], 1))))
    # We can cast here to float32 since this is used for camera calibration
    points_3D = points_3D.astype(np.float32)

    return points_3D

# %% ../nbs/01_camera_calibration.ipynb #f29b36de
def calibrate_camera_from_chessboard_images(image_files: list[str], pattern_size: tuple[int, int], f_save: bool=True):
    """
    Calibrate camera using multiple images of a chessboard pattern.
    
    Parameters:
    - image_files: List of file paths to calibration images.
    - pattern_size: Tuple indicating the number of inner corners per chessboard row and column (nx, ny).
    
    Returns:
    - camera_matrix: The camera matrix.
    - dist_coeffs: The distortion coefficients.
    """

    # Prepare object points based on the known flat chessboard pattern (cast to float32)
    objp = object_points_cheesboard_grid(pattern_size).astype(np.float32)

    # List of 3D points for each image
    objpoints = []  # 3d point in real world space
    imgpoints = []  # 2d points in image plane.
    # ---------------------------------------------------------------------
    # Criteria for cornerSubPix
    winSize = (11,11)
    zeroZone = (-1,-1) # no dead region
    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001) # max 30 iterations or move by at least 0.001


    for fname in image_files:
        img = cv2.imread(fname)
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

        ret, corners = cv2.findChessboardCorners(gray, pattern_size, None)

        if ret:
            corners_subpix = cv2.cornerSubPix(gray, corners, winSize, zeroZone, criteria)
            objpoints.append(objp)
            imgpoints.append(corners_subpix)

    _, camera_matrix, dist_coeffs, rvecs, tvecs = cv2.calibrateCamera(objpoints, imgpoints, gray.shape[::-1], None, None)

    # Calculate reprojection error
    mean_error = 0
    for i in range(len(objpoints)):
        imgpoints2, _ = cv2.projectPoints(objpoints[i], rvecs[i], tvecs[i], camera_matrix, dist_coeffs)
        error = cv2.norm(imgpoints[i], imgpoints2, cv2.NORM_L2) / len(imgpoints2)
        mean_error += error
    
    print(f"\nTotal reprojection error: {mean_error / len(objpoints)}")
    
    # Save the calibration results
    if f_save:
        save_path = os.path.dirname(image_files[0])
        # Save as a yaml file
        fs = cv2.FileStorage(os.path.join(save_path, 'camera_calibration.yaml'),
                            cv2.FILE_STORAGE_WRITE)

        fs.write("camera_matrix", camera_matrix)
        fs.write("dist_coeffs", dist_coeffs)
        fs.write("reprojection_error", mean_error / len(objpoints))
        fs.release()
        print(f"Calibration results saved to {os.path.join(save_path, 'camera_calibration.yaml')}")

    
    return camera_matrix, dist_coeffs

